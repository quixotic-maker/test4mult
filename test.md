

我们无法完全禁止AI，也无法100%检测出来。因此，我们的策略是**拥抱它，并超越它**。评测将由三部分构成，AI可以辅助完成第一部分，但很难伪造后两部分：

1. **代码实现 (Code)**: 功能是否完成，代码是否整洁、有注释。这是基础。
2. **开发过程 (Process)**: **Git提交历史是关键**。我们会要求候选人进行**频繁的、有意义的**提交。一个由AI一次性生成的完美项目，其提交历史是苍白的。一个真实的开发者，其历史会体现出“搭建环境->实现A功能->修复A的bug->重构B模块”的清晰足迹。
3. **设计阐述 (Explanation)**: 通过`README.md`文档和简短面试。候选人必须能清晰地解释自己的**设计思路、遇到的挑战、以及为什么做出某种技术选择**。这是对他们真实理解能力的“图灵测试”。

------



### 四个选拔项目 (周期：4天)





#### **项目一：感知工程师 (Perception Engineer)**



- **考察能力**: Python编程, OpenCV使用, AI模型API调用, 基础的图像几何理解。

- **项目名称**: **智能货架监控器 (Smart Shelf Monitor)**

- 项目简介:

  编写一个Python脚本，调用电脑摄像头。使用一个预训练的YOLOv8模型实时检测画面中的常见物体（例如：水杯cup, 笔记本laptop, 手机cell phone）。当检测到指定物体时，用方框标出，并在屏幕上打印出该物体边界框的中心点像素坐标 (x, y)。

- **技术要求**:

  - 语言: Python
  - 库: `OpenCV`, `ultralytics` (YOLOv8的官方库), `NumPy`

- **交付物**:

  1. 一个包含所有代码的GitHub仓库链接。
  2. 一份`README.md`，内容包括：
     - 如何配置环境和运行程序的说明。
     - 简述你的实现步骤。
     - **思考题**: 如果画面中同时出现多个水杯，你的程序会如何处理？如果需要获取物体在三维空间中的方向，仅靠当前信息足够吗？为什么？

- **评测要点**:

  - **Git历史**: 是否体现了从“调通摄像头” -> “加载YOLO模型” -> “成功检测” -> “计算中心点”的逻辑步骤？
  - **代码质量**: 能否正确处理未检测到物体时的异常情况？
  - **思维深度**: `README`中对思考题的回答，是否体现了对问题边界的理解？面试时可以追问：“如果中心点计算不准，可能是什么原因造成的？”

------



#### **项目二：运动工程师 (Motion Engineer)**



- **考察能力**: C++编程, ROS 2基础 (Node, Service), MoveIt API初次使用, URDF/SRDF的理解。

- **项目名称**: **仿真机械臂“点兵点将” (Simulated Arm Position Caller)**

- 项目简介:

  我们提供一个已配置好MoveIt的简单六轴机械臂的仿真功能包。你需要编写一个C++的ROS 2节点，该节点提供一个名为/move_to_position的服务。该服务接收一个string类型的请求（如"home", "pose1", "pose2"），然后驱动仿真机械臂运动到你在程序中**预先定义好的（硬编码）**对应关节角度位置。

- **技术要求**:

  - 语言: C++
  - 框架: ROS 2 Humble, MoveIt 2

- **交付物**:

  1. 一个包含你编写的C++功能包的GitHub仓库链接。
  2. 一份`README.md`，内容包括：
     - 如何编译和启动你的节点。
     - 简述你是如何调用MoveIt API来实现运动的。
     - **思考题**: 在你的实现中，机械臂是沿着直线运动到目标点的吗？如果不是，请解释为什么，并说明MoveIt中的“关节空间规划”和“笛卡尔空间规划”有何不同。

- **评测要点**:

  - **Git历史**: 是否能看出候选人在与`CMakeLists.txt`和C++编译器搏斗的痕迹？以及尝试调用MoveIt API的过程？
  - **代码质量**: C++代码结构是否清晰？是否正确使用了ROS 2的服务和MoveIt的`MoveGroupInterface`？
  - **概念理解**: `README`和面试中对思考题的回答，是否能清晰区分两种规划空间？这对于后续的运动规划开发至关重要。

------



#### **项目三：状态与执行工程师 (State & Execution Engineer)**



- **考察能力**: ROS 2多节点通信 (Service/Action), 状态管理, 异步编程逻辑。

- **项目名称**: **“智能咖啡厅”订单执行系统 (Smart Cafe Order System)**

- 项目简介:

  用Python编写两个ROS 2节点来模拟咖啡厅的后台：

  1. **`OrderManager`节点**: 提供一个Action服务`/submit_order`，接收订单（例如`['latte', 'cappuccino']`）。它负责维护所有订单的状态（`QUEUED`, `IN_PROGRESS`, `COMPLETED`）。
  2. **`BaristaBot`节点**: 作为一个客户端，不断地从`OrderManager`获取状态为`QUEUED`的订单。接收到订单后，它将订单状态更新为`IN_PROGRESS`，然后“制作”每一杯咖啡（通过`time.sleep()`模拟耗时），制作完成后将最终状态更新为`COMPLETED`。

- **技术要求**:

  - 语言: Python
  - 框架: ROS 2 Humble (重点考察Action的使用)

- **交付物**:

  1. 一个包含两个节点的ROS 2功能包的GitHub仓库链接。
  2. 一份`README.md`，内容包括：
     - 如何启动和测试整个系统。
     - 画出两个节点间的通信流程图。
     - **思考题**: 如果`BaristaBot`节点在制作一杯`latte`时崩溃了，当前的订单状态会是什么？你认为系统应该如何处理这种情况才能保证订单不会丢失？

- **评测要点**:

  - **Git历史**: 是否体现了先实现`OrderManager`，再实现`BaristaBot`，最后联调的开发过程？
  - **系统设计**: Action的使用是否规范？状态管理逻辑是否清晰，能否处理多个订单并发请求？
  - **鲁棒性思维**: 对思考题的回答，是否体现了对分布式系统中状态一致性和故障恢复的基本思考？这是执行监督模块的核心要求。

------



#### **项目四：任务与技能工程师 (Task & Skill Engineer)**



- **考察能力**: 抽象逻辑思维, 设计模式理解, 学习和使用新框架的能力。

- **项目名称**: **“机器人晨间流程”行为树 (Robot's Morning Routine BT)**

- 项目简介:

  使用Python的行为树库py_trees，构建一个模拟机器人早晨起床流程的行为树。你不需要控制任何真实或仿真的机器人，只需让行为节点打印信息即可。

  - **基础行为 (Action Nodes)**: `IsAlarmRinging` (检查闹钟，随机返回成功或失败), `HitSnoozeButton` (打印"Snoozing..."), `GetOutOfBed` (打印"Getting up!"), `BrewCoffee` (打印"Brewing coffee...")。
  - **任务逻辑**: 使用行为树的**控制流节点 (Control Flow Nodes)**，如`Sequence`（顺序执行）, `Selector`（选择其一）, `Parallel`（并行），来组合上述基础行为，实现一个有意义的流程。例如：“如果闹钟响了，机器人会选择‘起床’或‘按掉闹钟’；起床后，必须先‘冲咖啡’才能开始一天的工作”。

- **技术要求**:

  - 语言: Python
  - 框架: `py_trees` (ROS 2官方推荐的行为树库)

- **交付物**:

  1. 一个包含你的`py_trees`脚本的GitHub仓库链接。
  2. 一份`README.md`，内容包括：
     - 如何运行你的行为树。
     - 用文字或截图画出你的行为树结构。
     - **思考题**: 解释你在哪里使用了`Sequence`，在哪里使用了`Selector`，为什么？如果现在要增加一个条件“仅在工作日冲咖啡”，你会在行为树的哪个部分进行修改？

- **评测要点**:

  - **Git历史**: 是否能看出候选人从学习`py_trees`的API到逐步构建起整个树的探索过程？
  - **设计模式**: 行为树的结构是否逻辑清晰、易于理解和扩展？
  - **抽象能力**: 对思考题的回答，是否真正理解了行为树的核心思想？这直接关系到未来能否设计出复杂的任务流程。